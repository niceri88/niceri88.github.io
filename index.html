<!DOCTYPE html>
<html>
<head>
    <title>Ordenamientos | Yeri Porras</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f1f1f1;
            margin: 0;
            padding: 20px;
        }
        code {
            display: block;
            background-color: #002240;
            color: #ffffff;
            padding: 10px;
            border: 1px solid #ffffff;
            border-radius: 5px;
            font-family: Consolas, monospace;
            overflow-x: auto;
        }
        h1 {
            color: #002240;
        }
        p {
            color: #ffffff;
        }
        a {
            color: #f1f1f1;
            text-decoration: underline;
            font-weight: bold;
        }
        .container {
            background-color: #005cad;
            color:#ffffff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .rounded-img {
            border-radius: 2%;
        }
    </style>
</head>
<body>
    <h1>Ordenamientos</h1>
    <div class="container"> 
        <h2>Burbuja</h2>
        <p>
            Año de creación: El algoritmo de ordenamiento burbuja se desarrolló en la década de 1950.
        </p>
        <p>
            Autor: No se sabe a ciencia cierta quién lo creó, pero las primeras referencias apuntan a Edward H. Friend con el nombre "ordenamiento por intercambio"
        </p>
        <p>
            Tiempo de ejecución: El tiempo de ejecución del ordenamiento burbuja depende del número de elementos en la lista a ordenar, aumentando cuadráticamente con el tamaño 
        </p>
        <p>
            Eficiencia: El ordenamiento burbuja no es eficiente en comparación con otros algoritmos de ordenamiento más avanzados, especialmente para listas grandes. Su rendimiento es pobre y tiende a ser mucho más lento en comparación con algoritmos como Quicksort o merge.
        </p>
        <p>
            Características de la lista: Después de que se aplica el algoritmo de ordenamiento burbuja a una lista, los elementos se reorganizan de forma ascendente (o descendente, dependiendo de la implementación). El elemento más pequeño o grande se va trasladando gradualmente hacia el principio de la lista a medida que se realizan comparaciones y se intercambian elementos.
        </p>
        <center>
            <h3>Corrida a mano</h3>
            <img src="media\burbuja.jpg" alt="Corrida" class="rounded-img" width="30%" height="auto">
        </center>
        <h3>Intregracion en python</h3>
        <pre><code>
            def OrdenamientoBurbuja(lista):
                for i in range(1,len(lista)):
                    for j in range(0,len(lista)-i):
                        if lista[j]>lista[j+1]:
                            k=lista[j+1]
                            lista[j+1]=lista[j]
                            lista[j]=k
                        print(lista)
        </code></pre>   

        <h2>Seleccion</h2>
        <p>
            Año de creación: Desarrollado en 1959.
        </p>
        <p>
            Autor: Se atribuye a John McCarthy.
        </p>
        <p>
            Tiempo de ejecución: El tiempo de ejecución en el peor caso es de O(n^2), donde "n" es el número de elementos a ordenar.
        </p>
        <p>
            Eficiencia: No es eficiente para conjuntos de datos grandes debido a su complejidad cuadrática. Sin embargo, es simple de implementar y puede ser útil para conjuntos de datos pequeños o parcialmente ordenados.
        </p>
        <p>
            Características: El algoritmo de selección encuentra repetidamente el elemento mínimo de la lista no ordenada y lo intercambia con el primer elemento no ordenado. A medida que avanza, la porción ordenada de la lista crece desde el principio.
        </p>
        <center>
            <h3>Corrida a mano</h3>
            <img src="media\seleccion.jpg" alt="Corrida" class="rounded-img" width="30%" height="auto">
        </center>
        <h3>Intregracion en python</h3>
        <pre><code>
            def seleccion(lista):
                for i in range(0,len(lista)-1):
                    minimo=i
                    for j in range(i+1,len(lista)):
                        if lista[minimo]>lista[j]:
                            minimo=j
                        aux=lista[minimo]
                    lista[minimo]=lista[i]
                    lista[i]=aux
                print(lista)
        </code></pre>

        <h2>Insercion</h2>
        <p>
            Año de creación: Desarrollado en década de 1950.
        </p>
        <p>
            Autor: Se atribuye a varios investigadores como John von Neumann y Donald Shell.
        </p>
        <p>
            Tiempo de ejecución: El tiempo de ejecución en el peor caso es de O(n^2), donde "n" es el número de elementos a ordenar.
        </p>
        <p>
            Eficiencia: Al igual que el ordenamiento por selección, el ordenamiento por inserción no es eficiente para conjuntos de datos grandes. Sin embargo, también es simple de implementar y puede ser eficiente para conjuntos de datos pequeños o parcialmente ordenados.
        </p>
        <p>
            Características: El algoritmo de inserción construye una lista ordenada insertando cada elemento en su posición adecuada dentro de la lista ya ordenada. Comienza con una lista ordenada de un solo elemento y va insertando los elementos restantes en la posición correcta.
        </p>
        <center>
            <h3>Corrida a mano</h3>
            <img src="media\insercion.jpg" alt="Corrida" class="rounded-img" width="30%" height="auto">
        </center>
        <h3>Intregracion en python</h3>
        <pre><code>
            def insercion(lista):
                for i in range (1,len(lista)):
                    v=lista[i]
                    j=i-1
                    while j>=0 and lista[j]>v:
                        lista[j+1]=lista[j]
                        j=j-1
                    lista[j+1]=v
                    print(lista)
        </code></pre>

        <h2>Shell</h2>
        <p>
            Año de creación: El ordenamiento Shell fue propuesto en 1959.
        </p>
        <p>
            Autor: Donald Shell
        </p>
        <p>
            Tiempo de ejecución: El tiempo de ejecución del ordenamiento Shell depende del tamaño de la lista y de la secuencia de brechas utilizada y varía según la secuencia de brechas utilizada. En la práctica suele tener un mejor rendimiento que otros algoritmos de ordenamiento cuadráticos, como el ordenamiento burbuja.
        </p>
        <p>
            Eficiencia: El ordenamiento Shell es conocido por ser más eficiente que los algoritmos cuadráticos tradicionales, como el ordenamiento burbuja. Su eficiencia radica en la aplicación de comparaciones y movimientos de elementos en una serie de subsecuencias, lo que permite acelerar el proceso de ordenamiento. Sin embargo, el ordenamiento Shell no es tan eficiente como algunos de los algoritmos de ordenamiento más avanzados, como Quicksort o merge.
        </p>
        <p>
            Características de la lista: Después de aplicar el algoritmo de ordenamiento Shell a una lista, los elementos se reorganizan en orden ascendente o descendente, dependiendo de la implementación. El algoritmo utiliza una secuencia de brechas para realizar comparaciones y movimientos de elementos a través de diferentes subsecuencias de la lista. A medida que se aplican más pasadas del algoritmo con brechas más pequeñas, los elementos se acercan cada vez más a su posición final en la lista ordenada.
        </p>
        <center>
            <h3>Corrida a mano</h3>
            <img src="media\shell.jpg" alt="Corrida" class="rounded-img" width="30%" height="auto">
        </center>
            <h3>Intregracion en python</h3>
        <pre><code>
            def Shell(lista):
                inc=int(len(lista)/2 )
                while inc>0:
                    for  i in range(inc,len(lista)):
                        j=i
                        temp=lista[i]
                        while j>=inc and lista[j-inc]>temp:
                            lista[j]=lista[j-inc]
                            j=j-inc 
                        lista[j]=temp
                    if (inc==2) :
                        inc=1
                    else :
                        inc=int(inc/2.5)
                print(lista)
        </code></pre>

        <h2>Quicksort</h2>
        <p>
            Año de creación: Desarrollado en 1959.
        </p>
        <p>
            Autor: Se atribuye a Tony Hoare.
        </p>
        <p>
            Tiempo de ejecución: El tiempo de ejecución promedio es O(n log n), pero en el peor caso puede ser O(n^2).
        </p>
        <p>
            Eficiencia: Quicksort es generalmente eficiente y ampliamente utilizado en la práctica. Tiene una buena eficiencia promedio y requiere un espacio adicional mínimo.
        </p>
        <p>
            Características: Selecciona un elemento pivote de la lista y particiona los elementos restantes en dos subconjuntos: aquellos menores que el pivote y aquellos mayores que el pivote. Luego, aplica Quicksort recursivamente a cada subconjunto.
        </p>
        <center>
            <h3>Corrida a mano</h3>
            <img src="media\quicksort.jpg" alt="Corrida" class="rounded-img" width="30%" height="auto">
        </center>
        <h3>Intregracion en python</h3>
        <pre><code>
            def quicksort(lista):
                if len(lista) == 1 or len(lista) == 0:
                    return lista
                else:
                    pivot = lista[0]
                    print(pivot)
                    i = 0
                    for j in range(len(lista)-1):
                        if lista[j+1] < pivot:
                            lista[j+1],lista[i+1] = lista[i+1], lista[j+1]
                            i += 1
                    lista[0],lista[i] = lista[i],lista[0]
                    primera = quicksort(lista[:i])
                    segunda = quicksort(lista[i+1:])
                    primera.append(lista[i])   
                    print(primera + segunda)
                return (primera + segunda)
        </code></pre>

        <h2>Radix</h2>
        <p>
            Año de creación: Desarrollado en la década de 1880.
        </p>
        <p>
            Autor: No se atribuye a un autor específico.
        </p>
        <p>
            Tiempo de ejecución: El tiempo de ejecución es O(kn), donde "n" es el número de elementos y "k" es el número de dígitos o bits necesarios para representar el número más grande.
        </p>
        <p>
            Eficiencia: Radix es eficiente para clasificar números enteros o datos de tamaño fijo con una cantidad limitada de dígitos o bits. Sin embargo, puede requerir más tiempo y espacio si se aplica a datos con tamaño variable o datos no numéricos.
        </p>
        <p>
            Características: Clasifica los elementos examinando los dígitos individuales en lugar de comparar los elementos completos. Comienza por los dígitos menos significativos y va moviéndose hacia los más significativos.
        </p>
        <center>
            <h3>Corrida a mano</h3>
            <img src="media\radix.jpg" alt="Corrida" class="rounded-img" width="30%" height="auto">
        </center>
        <h3>Intregracion en python (utiliza funciones adicionales)</h3>
        <pre><code>
            def largo(num):
                copianum=num
                if isinstance(copianum,int):
                    cont=1 if copianum == 0 else 0
                    while copianum!=0:
                        copianum=copianum//10
                        cont+=1
                    return cont
                else:
                    print("no entero")

            def numalist(lista):
                numa=0
                for num in lista:
                    if num>numa:
                        numa=num
                return numa

            def radix(lista):
                numa=numalist(lista)
                largnum=largo(numa)
                for i in range(largnum):
                    list10 = [[]]*10
                    for num in lista:
                        digit=(num//(10**i))%10
                        list10[digit]=list10[digit]+[num]
                    j=0
                    for k in list10:
                        for num in k:
                            lista[j]=num
                            j=j+1
                return lista
        </code></pre>

        <h2>Shake</h2>
        <p>
            Año de creación: Desarrollado en la década de 1950.
        </p>
        <p>
            Autor: No se atribuye a un autor específico. 
        </p>
        <p>
            Tiempo de ejecución: El tiempo de ejecución en el peor caso es de O(n^2)
        </p>
        <p>
            Eficiencia: Shake es similar a otros algoritmos de ordenamiento cuadráticos en términos de eficiencia. Puede ser adecuado para conjuntos de datos pequeños o parcialmente ordenados.
        </p>
        <p>
            Características: Shake es una variante del ordenamiento por burbuja. A diferencia del ordenamiento por burbuja, shake realiza pasadas en ambas direcciones de la lista, moviendo el elemento más grande al final y el más pequeño al principio en cada pasada.
        </p>
        <center>
            <h3>Corrida a mano</h3>
            <img src="media\shake.jpg" alt="Corrida" class="rounded-img" width="30%" height="auto">
        </center>
        <h3>Intregracion en python</h3>
        <pre><code>
            def shake_sort(lista):
            left = 0
            right = len(lista) - 1
            while left <= right:
                for i in range(left, right):
                    if lista[i] > lista[i + 1]:
                        lista[i], lista[i + 1] = lista[i + 1], lista[i]
                right -= 1
                for i in range(right, left, -1):
                    if lista[i - 1] > lista[i]:
                        lista[i], lista[i - 1] = lista[i - 1], lista[i]
                left += 1
            return lista
        </code></pre>

        <h2>Merge</h2>
        <p>
            Año de creación: Desarrollado por primera vez en 1945.
        </p>
        <p>
            Autor: Se atribuye a John von Neumann.
        </p>
        <p>
            Tiempo de ejecución: El tiempo de ejecución siempre es O(n log n).
        </p>
        <p>
            Eficiencia: Merge es eficiente y ampliamente utilizado en la práctica. Tiene un buen rendimiento en conjuntos de datos grandes.
        </p>
        <p>
            Características: Merge sort divide la lista original en sublistas más pequeñas, las ordena recursivamente y luego las fusiona para obtener una lista ordenada.
        </p>
        <center>
            <h3>Corrida a mano</h3>
            <img src="media\merge.jpg" alt="Corrida" class="rounded-img" width="30%" height="auto">
        </center>
        <h3>Intregracion en python</h3>
        <pre><code>
            def merge_sort(lista):
                if len(lista) < 2:
                    return lista
                else:
                    middle = len(lista) // 2
                    right = merge_sort(lista[:middle])
                    left = merge_sort(lista[middle:])
                    return merge(right, left)
            def merge(lista1, lista2):
                i, j = 0, 0
                result = []
                while(i < len(lista1) and j < len(lista2)):
                    if (lista1[i] < lista2[j]):
                        result.append(lista1[i])
                        i += 1
                    else:
                        result.append(lista2[j])
                        j += 1
                result += lista1[i:]
                result += lista2[j:]
                return result
        </code></pre>
    </div>
    <h1>Busquedas</h1>
    <div class="container"> 
        <h2>Binaria</h2>
        <p>
            Año de creación: El algoritmo de búsqueda binaria se popularizó en la década de 1940.
        </p>
        <p>
            Autor: John W. Tukey es reconocido por su contribución al desarrollo de la búsqueda binaria.
        </p>
        <p>
            Tiempo de ejecución: La búsqueda binaria tiene un tiempo de ejecución logarítmico, lo que significa que su eficiencia aumenta a medida que el tamaño de la lista aumenta.
        </p>
        <p>
            Eficiencia: La búsqueda binaria es considerada un algoritmo de búsqueda eficiente debido a su tiempo de ejecución logarítmico. A medida que la lista aumenta de tamaño, la búsqueda binaria puede encontrar un elemento en menos comparaciones en comparación con algoritmos de búsqueda lineal como la búsqueda secuencial.
        </p>
        <p>
            Características de la lista resultante: La búsqueda binaria determina si un elemento específico está presente en la lista ordenada o no. Si el elemento se encuentra en la lista, devuelve la posición o índice en el que se encuentra. En caso contrario, devuelve un valor que indica que el elemento no está presente. Como detalle adicional, es necesario que la lista en la que se va a buscar el elemento esté ordenada, caso contrario hay que ordenarla antes de buscar.
        </p>
        <center>
            <h3>Corrida a mano</h3>
            <img src="media\binaria.jpg" alt="Corrida" class="rounded-img" width="30%" height="auto">
        </center>
        <h3>Intregracion en python</h3>
        <pre><code>
            def busquedaBinaria(lista,item):
                primero=0
                ultimo=len(lista)-1
                encontrado=False
                while primero <=ultimo and not encontrado:
                    puntoMedio=(primero+ultimo)//2
                    if lista[puntoMedio]==item:
                        encontrado=True
                    else:
                        if item< lista[puntoMedio]:
                            ultimo=puntoMedio-1
                        else:
                            primero=puntoMedio+1
                print (encontrado)
        </code></pre>

        <h2>Secuencial</h2>
        <p>
            Año de creación: No tiene un año específico, ya que es un algoritmo básico de búsqueda.
        </p>
        <p>
            Autor: No se atribuye a un autor específico.
        </p>
        <p>
            Tiempo de ejecución: El tiempo de ejecución en el peor caso es O(n), donde "n" es el número de elementos en la lista.
        </p>
        <p>
            Eficiencia: La búsqueda secuencial es simple de implementar, pero su eficiencia es lineal y no es adecuada para conjuntos de datos grandes.
        </p>
        <p>
            Características: La búsqueda secuencial recorre secuencialmente cada elemento de la lista hasta encontrar el elemento buscado. Es adecuada para listas no ordenadas.
        </p>
        <center>
            <h3>Corrida a mano</h3>
            <img src="media\secuencial.jpg" alt="Corrida" class="rounded-img" width="30%" height="auto">
        </center>
        <h3>Intregracion en python</h3>
        <pre><code>
            def busquedaSecuencial(lista,nume):
                posicion=0
                encontrado=False
                while posicion < len(lista) and not encontrado:
                    if lista[posicion]== nume:
                        encontrado = True
                    else:
                        posicion = posicion+1
                print (encontrado)
        </code></pre>
    </div>
    <h2>Referencias</h2>
    <div class="container">
        <ul>
            <li><a href="http://analizaralgoritmos.blogspot.com/2013/03/metodo-burbuja.html?m=1">Burbuja</a></li>
            <li><a href="http://lwh.free.fr/pages/algo/tri/tri_selection_es.html">Seleccion</a></li>
            <li><a href="https://juncotic.com/ordenamiento-por-insercion-algoritmos-de-ordenamiento/#:~:text=El%20algoritmo%20de%20ordenamiento%20por%20inserci%C3%B3n%20es%20un%20algoritmo%20de,insert%C3%A1ndolo%20en%20el%20lugar%20correspondiente.">Insercion</a></li>
            <li><a href="https://es.wikipedia.org/wiki/Ordenamiento_Shell">Shell</a></li>
            <li><a href="http://lwh.free.fr/pages/algo/tri/tri_shell_es.html#:~:text=La%20ordenaci%C3%B3n%20de%20Shell%20pertenece,una%20segmentaci%C3%B3n%20entre%20los%20datos.">Shell</a></li>
            <li><a href="https://gsauceda1.wixsite.com/quicksort/historia#:~:text=El%20algoritmo%20Quicksort%20fue%20desarrollado,de%20F%C3%ADsica%20(Reino%20Unido).">Quicksort</a></li>
            <li><a href="http://radixsort.byethost7.com/?i=1">Radix</a></li>
            <li><a href="https://slideplayer.es/slide/17459739/">Shake</a></li>
            <li><a href="https://pythondiario.com/2018/08/ordenamiento-por-mezcla-merge-sort.html">Merge</a></li>
            <li><a href="https://binarycoffee.dev/post/conociendo-el-ordenamiento-por-mezcla-merge-sort">Merge</a></li>
            <li><a href="https://numerentur.org/busqueda/#:~:text=La%20primera%20vez%20que%20se,de%20aqu%C3%AD%20surgen%20distintas%20versiones.">Busqueda Binaria</a></li>
            <li><a href="https://es.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search">Busqueda Binaria</a></li>
            <li><a href="http://cidecame.uaeh.edu.mx/lcc/mapa/PROYECTO/libro9/bsqueda_secuencial.html">Busqueda Secuencial</a></li>
        </ul>
    </div>
</body> 
</html>
